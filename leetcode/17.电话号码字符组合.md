```go
var mmap []string = []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
var results []string = []string{}
// DFS（回溯）
func letterCombinations(digits string) []string {
	if len(digits) == 0 {
		return []string{}
	}
	backtrace(digits, 0, "")
	return results

}
func backtrace(digits string, index int, res string) {
	if index == len(digits) {
		results = append(results, res)
	} else {
		digit := int((digits[index])) - 48
		letters := mmap[digit]
		for i := range letters {
			backtrace(digits, index+1, res+string(letters[i]))
		}
	}
}
// BFS广度优先遍历
func bfs(digits string) []string {
	// 从队列中取出每一层中的数据依次拼接后再放入队列
	results := make([]string, 0, 0)
	queue := make([]string, 1, len(digits))
	queue[0] = ""
	// 遍历的层次,让每一层对应的 字母串 都和队列中已有字符串进行拼接
	for i := range digits {
		digit := int(digits[i]) - 48
		letters := mmap[digit]
		// 遍历队列，取得队列中已完成拼接的字符串
		for range queue {
			tmpStr := queue[0]
			queue = queue[1:]
			// 遍历这一层的 字母串 将其拼接到队列中的字符串的每一个的尾部
			for j := range letters {
				queue = append(queue, tmpStr+string(letters[j]))
			}
		}
	}
	for len(queue) > 0 {
		results = append(results, queue[0])
		queue = queue[1:]
	}
	return results
}