```go
func longestPalindrome(s string) string {
	// 中心扩展法
	if s == "" {
		return s
	}
	start, end := 0, 0
	// 以每一个字符为中心向外扩展
	// 回文串中心字符可能是单个字符也可能是相等的双字符
	// 两种情况都计算出结果，取其中的最大值
	for i := range s {
		l1, r1 := expand(s, i, i)
		l2, r2 := expand(s, i, i+1)
		if r1-l1 > end-start {
			start, end = l1, r1
		}
		if r2-l2 > end-start {
			start, end = l2, r2
		}
	}
	return s[start : end+1]
}
func expand(s string, left, right int) (int, int) {
	for ; left >= 0 && right < len(s) && s[left] == s[right]; left, right = left-1, right+1 {
	}
	return left + 1, right - 1
}
/*
动态规划：
用dp[n][n]矩阵用来保存是否能构成回文的状态，如从 i 到 j 可以构成回文，则dp[i][j]=true
状态转移方程为：dp[i][j] = dp[i+1][j-1] && s[i] == s[j]
判断区间：（j-1） -（i+1）+ 1 < 2 当只有一个字符时即为边界条件
   j右 0 1 2 3 4...... n
 i左   -----------------
  0 | 1
  1 |   1
  2 |     1
  3 |       1
  4 |          1
  ..            .....
  ....           ....
  .....           ...
  n |                 1

dp = [n][n]int{}
// l 表示回文串长度 = l + 1
for l=0;l<n;l++{
	// i表示左边界
    for i=0;i<n-l;i++{
		// j表示右边界
        j = i+l
        // 先把对角线上的状态设置为true
		// l == 0 则 i == j
        if l == 0 {
			
            dp[i][j] = 1
        }
		else if l == 1 {
			// l == 1 则 j == i+1
			// 这里用于判断回文串中心是两个相等字符的情况
			if s[i] == s[j] {
				dp[i][j] = 1
			}
		}
		// 根据状态转移方程填充矩阵，可知当前状态取决于矩阵中左下方的状态
		else {
			if s[i] == s[j] {
				// 更新dp[i][j]的值为 dp[i+1][j-1]
			}
		}
		// 判断长度 更新 res 回文子字符串
		if 是回文 && 长度>len(res) {
			res = s[i:i+l+1]
		}
    }
}

*/
```