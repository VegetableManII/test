package main

import (
	"fmt"
	"math"

	. "study/newcoder/tree"
)

var preNode = math.MinInt32

func main() {
	t := CreateTree([]int{140, 57, 156, 40, 123, 154, 172, 32, 51, 90, 133, 143, 155, 160, 173, 25, 36, 48, 56, 61, 111, 129, 139, 142, 152, -1, -1, 158, 166, -1, -1, 18, 28, 34, 38, 42, 50, -1, 54, 60, 71, 103, 119, 126, 131, -1, 137, 141, -1, 147, 153, 157, 159, 165, 170, 10, 23, 27, 30, 33, 35, 37, 39, 41, 45, -1, 49, 53, 55, -1, 59, 70, 88, 97, 108, 114, 122, 125, 128, 130, 132, 135, 138, -1, -1, 146, 149, -1, -1, -1, -1, -1, -1, -1, 163, 168, 171, 8, 16, 21, 24, 26, -1, 29, 31, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, 47, -1, -1, -1, 52, -1, -1, 58, -1, -1, 67, 81, 89, 94, 100, 106, 110, 113, 116, -1, 121, 124, -1, 127, -1, -1, -1, -1, -1, 134, 136, -1, -1, -1, 145, 148, 151, 162, 164, 167, 169, -1, -1, 7, 9, 15, 17, 20, 22, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, 46, -1, -1, -1, -1, 65, 69, 76, 84, -1, -1, 92, 96, 99, 102, 105, 107, 109, -1, -1, 112, 115, 118, 120, -1, -1, -1, -1, -1, -1, -1, -1, -1, 144, -1, -1, -1, 150, -1, 161, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, 13, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, 64, 66, -1, 68, 75, 80, 83, 86, 91, 93, 95, -1, -1, 98, -1, 101, 104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 117, -1, -1, -1, -1, -1, -1, -1, -1, 2, 6, 12, 14, -1, -1, 63, -1, -1, -1, -1, -1, -1, 74, -1, 78, -1, 82, 85, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1, -1, -1, 11, -1, -1, -1, 62, 73, -1, 77, 79, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 72, -1}, 0)
	fmt.Println(isBST(t), isCBTree(t))
}

// 中序遍历
func isBST(t *TreeNode) bool {
	if t == nil {
		return true
	}
	if !isBST(t.Left) {
		return false
	}
	if preNode > t.Val {
		return false
	}
	preNode = t.Val
	if !isBST(t.Right) {
		return false
	}
	return true
}

// 层序遍历
func isCBTree(t *TreeNode) bool {
	queue := []*TreeNode{}
	queue = append(queue, t)
	for len(queue) != 0 {
		tmp := queue[0]
		queue = queue[1:]
		if tmp.Left != nil && tmp.Right != nil {
			queue = append(queue, tmp.Left)
			queue = append(queue, tmp.Right)
		} else if tmp.Left == nil && tmp.Right != nil {
			return false
		} else {
			// 当满足 (left != nil && right == nil) || (left == nil && right == nil)时说明
			// 此时已经遍历到倒数第二层
			for len(queue) != 0 {
				tmp := queue[0]
				queue = queue[1:]
				if tmp.Left != nil || tmp.Right != nil {
					return false
				}
			}
		}
	}
	return true
}
